#include "Utility.h"
#include <csignal>
#include <string>
#include <unistd.h>
#include <iostream>
#include <filesystem>
#include <thread>
#include <chrono>
#include <cstdio>
#include <fstream>
#include <sqlite3.h>
// pythonHandle Class Implementation

fileHandle::fileHandle(const std::string& fileName){
    sqlite3* s3dB;
    int rc = sqlite3_open(fileName.c_str(), &s3dB);
    if(rc)  {std::cerr << "Could not open market DB in constructor!\n";}
    else    {std::cout << "Market DB opened successfully in constructor!\n";} 
}

fileHandle::~fileHandle(){
    if(s3dB != nullptr){
        sqlite3_close(s3dB);
        s3dB = nullptr;
        std::cout << "Market DB closed by destructor!\n";
    }
}
bool fileHandle::fileExists(const std::string& fileName)
{
    // needs to be a string literal + "a" -> create if doesn't exist
    std::ofstream filePath(fileName);

    if (filePath.is_open()) {return true;}
    else {return false;}
}

/// Read text data from file generated by MarketInterface.py.
/// @param fileLocation Path to the file to read.
/// @param data The text to append to the file.
void fileHandle::fileRead(const std::string& fileLocation)
{
    std::ifstream file(fileLocation);
    if (file.is_open())
    {
        std::string line;
        while (getline(file, line))
        {
            std::cout << line << std::endl; 
        }
        file.close();
    }

    else
    {
        std::cerr << "Unable to open file: " << fileLocation << std::endl;
    }
}
/// Write text data to file holding our tracking information, such as current amount of money held..
/// @param fileLocation Path to the file to read.
/// @param data The text to write to the file.
void fileHandle::fileWrite(std::string& fileLocation, std::string data)
{
    std::ofstream file(fileLocation);
    if (!file.is_open())
    {
        std::cerr << "Unable to open file for writing: " << fileLocation << std::endl;
        return;
    }
    // file will be closed automatically when it goes out of scope
    file << "Sample log entry\n";
}

void fileHandle::dataBaseRead(const std::string& dbLocation)
{
    // Placeholder for database read functionality
    sqlite3* s3dB;
    int rc = sqlite3_open(dbLocation.c_str(), &s3dB);
    if(rc) {std::cerr << "Can't open DB: " << sqlite3_errmsg(s3dB) << std::endl;}
    else {std::cout << "Opened database successfully\n";}

    const char* sql = "SELECT * FROM MARKET_DATA;";
    sqlite3_stmt* stmt;
    sqlite3_prepare_v2(s3dB, sql, -1, &stmt, nullptr);
    double closePrice = sqlite3_column_double(stmt, 4); // assuming close price is in the 5th column (index 4)
    sqlite3_finalize(stmt);
    sqlite3_close(s3dB);
    std::cout << "Close Price from DB: " << closePrice << std::endl;
    
}

/// impelmentation for calling the python file that fetches market data
void pythonHandle::dataIngestionStartup(const std::string& pythonExePath) {
    // use filesystem to get current path
    namespace fs = std::filesystem;
    fs::path projectPath = fs::current_path().parent_path();
    fs::path fullPath = projectPath / "src"/ "TradingHandle" / "MarketInterface.py";
    std::cout << "Starting Python data ingestion process at: " + fullPath.string() << std::endl;
    std::string cmd = "python3 " + fullPath.string();
    // didnt even know you could 
    int result = std::system(cmd.c_str());
    if (result == -1) {
        std::cerr << "Error starting Python process." << std::endl;
    } else {
        std::cout << "Python process started successfully." << std::endl;
    }
}

/// @brief  Stops the python data ingestion process.
/// @param pyPID 
/// @return 
bool pythonHandle::dataIngestionStop(pid_t& pyPID){
        // send SIGTERM kill signal, see if it kills process
        kill(pyPID, SIGTERM);
        for (int i=0; i<10; ++i)
        {
            if (!programHeartbeatCheck(pyPID))
            {
                std::cout << "Data fetcher terminated at PID: " << pyPID << std::endl;
                return true;
            }
            std::this_thread::sleep_for(std::chrono::seconds(1));
        }

        // if process was not killed, throw process error for kill
        std::__throw_runtime_error("Process was not killed. able to be killed.\nCheck to make sure file exists");
        perror("kill");
        return false;
}

/// @brief Checks if python market reporting pipeline is still alive. 
/// @param pyPID 
/// @return 
bool pythonHandle::programHeartbeatCheck(pid_t& pyPID){
    // kill (pid_t pid, int sig = 0 ) is a probe mode - checks if process is alive
    return (kill(pyPID, 0) == 0);
}

/// @brief Will return the current paper money balance, or will give user option to create the default file. If file does not exist, create 
/// file for user.
/// @param fileLocation Location where balance file is located
/// @returns current balance in file
double moneyHandle::getCurrentBalance(const std::string& fileLocation)
{
    std::string line{};
    std::string balanceStr{};
    double balanceVal{};
    bool found = false;

    bool exists = std::filesystem::exists(fileLocation);
    if(exists)
    {
        std::ifstream file(fileLocation);
        while(getline(file, line))
        {
            if(line.rfind("balance=", 0) == 0)
            {
                // get the rest of the string after = sign, then do a static cast to a double.
                balanceStr = line.substr(line.find("=") + 1, line.size());
                balanceVal = std::stod(balanceStr);
                std::cout << "Current balance is: " << balanceVal << std::endl;
                found = true;
                return balanceVal;
            }
        }
        if(!found)
        {
            std::cout << "Balance entry not found in file: " << fileLocation << std::endl;
            std::cout << "Would you like to start with a new account with initial balance of 10000.00? (y/n)" << std::endl;
            char userInput;
            std::cin >> userInput;
            if(userInput=='y' || userInput=='Y')
            {
                std::ofstream file(fileLocation);
                file << "balance=10000.00" << std::endl;
                std::cout << "New account created with balance of 10000.00!" << std::endl;
                file.close();
                return 10000.00;
            }
            if(userInput=='n' || userInput=='N')
            {
                std::cout << "Exiting program. Please create an account file with a balance entry." << std::endl;
                exit(0);
            }
        }
    }

    else
    {
        std::cout << "File does not exist at location: " << fileLocation << std::endl;
        std::cout << "Creating a new account with initial balance of 10000.00" << std::endl;

        std::ofstream file(fileLocation);
        file << "balance=10000.00" << std::endl;
        std::cout << "New account created with balance of 10000.00!" << std::endl;
        file.close();
        return 10000.00;
    }
    return 0.0; // default return if nothing else works -> should never reach here
}

void moneyHandle::updateBalance(const std::string& fileLocation, double newBalance)
{
    std::ofstream file(fileLocation);
    if (!file.is_open())
    {
        std::cerr << "Unable to open file for writing: " << fileLocation << std::endl;
        return;
    }
    file << "balance=" << newBalance << std::endl;
}

